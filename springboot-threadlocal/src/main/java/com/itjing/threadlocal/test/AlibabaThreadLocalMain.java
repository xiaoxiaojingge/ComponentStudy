package com.itjing.threadlocal.test;

import com.alibaba.ttl.TransmittableThreadLocal;
import com.alibaba.ttl.threadpool.TtlExecutors;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * TransmittableThreadLocal 是Alibaba开源的 用于解决 “在使用线程池等会缓存线程的组件情况下传递ThreadLocal” 问题的
 * InheritableThreadLocal 扩展。 ThreadLocal只在当前线程中能访问到，其他线程隔离。
 * InheritableThreadLocal能够传递给子线程。
 * 对于线程池中的线程复用，将当前线程中的ThreadLocal传递给线程池中的其他线程，TransmittableThreadLocal提供了解决方案。
 */
public class AlibabaThreadLocalMain {

	// 需要注意的是，使用TTL的时候，要想传递的值不出问题，线程池必须得用TTL加一层代理（下面会讲这样做的目的）
	private static ExecutorService executorService = TtlExecutors
		.getTtlExecutorService(Executors.newFixedThreadPool(2));

	private static ThreadLocal tl = new TransmittableThreadLocal<>(); // 这里采用TTL的实现

	public static void main(String[] args) {

		new Thread(() -> {

			String mainThreadName = "main_01";

			tl.set(1);

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			sleep(2000L); // 确保上面的会在tl.set执行之前执行
			tl.set(2); // 等上面的线程池第一次启用完了，父线程再给自己赋值

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			System.out.println(String.format("线程名称-%s, 变量值=%s", Thread.currentThread().getName(), tl.get()));

		}).start();

		new Thread(() -> {

			String mainThreadName = "main_02";

			tl.set(3);

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			sleep(2000L); // 确保上面的会在tl.set执行之前执行
			tl.set(4); // 等上面的线程池第一次启用完了，父线程再给自己赋值

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			executorService.execute(() -> {
				sleep(2000L);
				System.out.println(String.format("本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s", mainThreadName,
						Thread.currentThread().getName(), tl.get()));
			});

			System.out.println(String.format("线程名称-%s, 变量值=%s", Thread.currentThread().getName(), tl.get()));

		}).start();

	}

	private static void sleep(long time) {
		try {
			TimeUnit.MILLISECONDS.sleep(time);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

}
